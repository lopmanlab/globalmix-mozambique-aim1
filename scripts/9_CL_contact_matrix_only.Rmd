---
title: "CL_contact matrix"
output: html_document
date: "2022-08-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libs, include=FALSE, warnings=FALSE}
library(dplyr)
library(tidyr)
library(socialmixr) ## Need socialmixr package version 0.2.0
library(ggplot2)
library(table1)
library(gtsummary)
library(ggpubr)
library(cowplot)
```

## Read in data
```{r read_data, include=FALSE, warnings=FALSE}
ind <- readRDS("../data/clean/participant_data_aim1.RDS")
ind_exit <- readRDS("../data/clean/exit_interview_aim1.RDS")
contact <- readRDS("../data/clean/contact_data_aim1.RDS")
#contact_nonhh <- readRDS("../data/clean/ind_contact_nonhh.RDS")
hh_survey <- readRDS("../data/clean/household_survey_aim1.RDS")
loc <- readRDS("../data/clean/locations_visited_aim1.RDS") ## loc clean
loc_orig <- readRDS("../data/clean/old_data/ind_location_visit.RDS")
loc_orig2 <- readRDS("../data/clean/old_data/ind_location_visit2.RDS")
```

Subset to aim 1 only
```{r subset_aim1, include=FALSE, warnings=FALSE}
## Subset individual_info to those included in aim1 only and only those who compelted exit interview
ind <- ind %>% 
  filter(aim ==1) %>% ## retain 1328 from aim 1
  filter(rec_id %in% unlist(ind_exit$rec_id)) ## retain 1270, only those with exit survey ie completed survey

## Subset contact to the IDs from aim 1 only
contact<- contact %>%
              filter(rec_id %in% unlist(ind$rec_id))

```

Check to see if there are any IDs with no contacts reported
```{r no_contacts, include=FALSE, warnings=FALSE}
sum(!ind$rec_id %in% contact$rec_id) # 84
#sum(!ind$rec_id %in% contact_nonhh$rec_id) # 28

## Figure out which ones
# missing_hh_nonhh <- ind %>%
#   filter(!rec_id %in% unlist(contact_hh$rec_id)) %>%
#   filter(!rec_id %in% unlist(contact_nonhh$rec_id)) %>%
#   arrange(rec_id)

missing<- ind %>% 
  filter(!rec_id %in% unlist(contact$rec_id)) %>% 
  arrange(rec_id)


```


Remove those with exit interviews but without contact diaries
```{r, , include=FALSE, warnings=FALSE}
ind <- ind %>%
    filter(!rec_id %in% unlist(missing$rec_id)) 
## Dropped an additional 78 without any diaries 
```


Check if those without household contact but have other contacts live alone
```{r, , include=FALSE, warnings=FALSE}

live_alone <- hh_survey %>% 
  filter(rec_id %in% unlist(ind$rec_id)) %>%
  filter(hh_occupants==1) 

```

```{r, include=FALSE, warnings=FALSE}
## Note that self refers to HoH not the participant, it looks like the entry for the participant has already been removed from the HH contacts

## Join with participant info to get age of the participant
contact<- contact %>%
                left_join(ind%>%select(rec_id, age), by = c("rec_id"="rec_id"))%>%
                rename(age_part = age) ##rename to fit the socialmixr package convention

## Recategorize location of contact based on socialmixr package convention
contact <- contact %>%
              mutate(cnt_home = ifelse(location_contact___0==1, 1,0),
                     cnt_school = ifelse(location_contact___2==1, 1,0),
                     cnt_work = ifelse(location_contact___3==1, 1,0),
                     cnt_otherplace = ifelse(location_contact___1==1 | 
                                               location_contact___4==1 | 
                                               location_contact___5==1 | 
                                               location_contact___6==1 | 
                                               location_contact___7==1 |
                                               location_contact___8==1 | 
                                               location_contact___9==1 |
                                               location_contact___10==1 | 
                                               location_contact___11==1,1,0))

##Subset to day 1 only
#contact<-contact%>%filter(study_day==1)

```

## Manually calculating weights based rural/urban age structure from 2021 Moz pop projections
Since we're interested in matrices weighted to total Moz population, we can get weighted matrices by specifying and country and the year in the survey structure below. 
NB: I still can't get the manual weighting to work in the function 
```{r, include=FALSE, warnings=FALSE}
contact <- contact %>%
                rename(part_id = rec_id)%>%   ##rename to fit socialmixr package
                rename(part_age = age_part)

contact <-contact%>%mutate(
          part_age = as.numeric(part_age),
          weight_cat = case_when(              ##age categories to join with population weighting
                          part_age ==0 ~ "0",
                          part_age<=4  ~ "1-4y",
                          part_age<=9  ~ "5-9y",
                          part_age<=14 ~ "10-14y",
                          part_age<=19 ~ "15-19y",
                          part_age<=29 ~ "20-29y",
                          part_age<=39 ~ "30-39y",
                          part_age<=59 ~ "40-59y",
                          part_age<=100 ~ "60+y",
                          TRUE ~ NA_character_
          )
)
pop_dist <- read.csv("../data/clean/pop_dist_ines_2021.csv") %>%
            pivot_longer(cols=urban:rural, names_to = "urb_rur", values_to = "tot_pop") %>%
            mutate(study_site = case_when(
                        urb_rur =="urban" ~"Urban",
                        urb_rur == "rural"~"Rural"
            ))



pop_weight <- contact%>%
                select(part_id, study_site,weight_cat) %>% unique() %>%
                group_by(study_site, weight_cat) %>%
                summarise(n=n())
urb_pop <- sum(pop_dist$tot_pop[which(pop_dist$urb_rur=="urban")])
rur_pop <- sum(pop_dist$tot_pop[which(pop_dist$urb_rur=="rural")])

pop_weight <- pop_weight %>% 
  left_join(pop_dist, by = c("weight_cat"="age_cat","study_site"="study_site"))%>%
  left_join(pop_weight%>%group_by(study_site)%>%summarise(tot_site = sum(n)), by = c("study_site"="study_site"))%>%
  mutate(pop_urb_rur =ifelse(study_site=="Rural",rur_pop,urb_pop),
           part_weight = (tot_pop/pop_urb_rur)/(n/tot_site))

##join weights into participant data
contact <- contact %>%
  left_join(pop_weight %>% select(study_site, weight_cat, part_weight),
                by = c("study_site"="study_site", "weight_cat"="weight_cat"))
 # rename(population.count = tot_pop)

         
```

##Create survey structures for input into socialmixr package
```{r, include=FALSE, warnings=FALSE}
contact <- contact %>% 
  mutate(part_age = as.numeric(part_age),
         contact_age = as.character(contact_age),
         
         cnt_age_est_min = case_when( ## If dont have exact contact age, need to specify a minimum and maximum based on the age group range
           contact_age == "<6mo" ~0,
           contact_age == "6-11mo"~0,
           contact_age == "1-4y" ~1,
           contact_age == "5-9y" ~ 5,
           contact_age == "10-14y"~10,
           contact_age == "15-19y"~15,
           contact_age == "20-29y"~20,
           contact_age == "30-39y"~30,
           contact_age == "40-59y"~40,
           contact_age == "60+y"~60,
           contact_age== "I don't know" ~ NA_real_,
           is.na(contact_age) ~ NA_real_
         ),
         
         cnt_age_est_max= case_when(
           contact_age == "<6mo" ~0,
           contact_age == "6-11mo"~1,
           contact_age == "1-4y" ~ 4,
           contact_age == "5-9y" ~ 9,
           contact_age == "10-14y"~14,
           contact_age == "15-19y"~19,
           contact_age == "20-29y"~29,
           contact_age == "30-39y"~39,
           contact_age == "40-59y"~59,
           contact_age == "60+y"~99,
           contact_age== "I don't know" ~ NA_real_,
           is.na(contact_age) ~ NA_real_
         )
  ) 

##Create the survey structure for input into socialmixr package
# One urban and one rural
cnt_u <- contact %>% filter(study_site == "Urban")

cnt_r <- contact%>% filter(study_site == "Rural")


df_r <- survey(
        participants = cnt_r %>% 
                        select(part_id, part_age,part_weight) %>% unique()%>%
                        rename(weights = part_weight)%>%
                        mutate(country=rep("Mozambique"),
                               year=rep(2020)),
        
        contacts = cnt_r %>%
                        select(part_id,cnt_age_est_min, cnt_age_est_max, cnt_home:cnt_otherplace)
                
)

df_u <- survey(
        participants = cnt_u %>% 
                        select(part_id, part_age,part_weight) %>% unique()%>%
                        rename(weights = part_weight)%>%
                        mutate(country=rep("Mozambique"),
                               year=rep(2020)),
        
        contacts = cnt_u %>%
                        select(part_id,cnt_age_est_min, cnt_age_est_max, cnt_home:cnt_otherplace)
                
)
```


###Matrices
```{r}
## urban
#Below code returns a list of matrix
m_u <- contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=T,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                     weigh.age = T,
                      return.part.weights=T,
                      n=2)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u <- Reduce("+", lapply(m_u$matrices, function(x) {x$matrix})) / length(m_u$matrices)



#Make into long form
mat_u <- reshape2::melt(mr_u, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c(1,2,3),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")

#Do same for rural
m_r <- contact_matrix(df_r, age.limits = c(0,18,50,99),symmetric=T, 
                      missing.contact.age="sample",estimated.contact.age = "sample",
                      return.part.weights = T,n=1000)


mr_r <- Reduce("+", lapply(m_r$matrices, function(x) {x$matrix})) / length(m_r$matrices)
mat_r <- reshape2::melt(mr_r, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c(1,2,3),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")


```

## Matrix Viz
```{r}
ggplot(mat_u, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
    theme()

ggplot(mat_r, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+ 
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
    theme()


```
##Function below helps filter on contact attributes to create attribute-specific matrices
SUch as by location etc. 
```{r}
### Create a contact matrix with filters

## Put filter = TRUE
## Then put the value to filter by in the various filter variables

cm_filter <- function(
  df  = df,
  matrix_output = TRUE,
  #country = "United States",
  age_limits =c(0,10,20,30,40,50,60),
  symmetric =TRUE,
  filter = FALSE,
  phys_contact = NULL,
  home  = NULL,
  other_house = NULL,
  work = NULL,
  school = NULL,
  gender = NULL,
  other = NULL,
  boots = 1
){
  
  filter_text <- list()
  
  if(filter){
    filter_text$phys_contact <- phys_contact
    filter_text$cnt_home <- home
    filter_text$cnt_other_house <- other_house
    filter_text$cnt_work <- work
    filter_text$cnt_school <- school
    filter_text$cnt_otherplace <- other
    filter_text$cnt_gender <- gender
  }
  
  x <- contact_matrix(
    df, 
    #countries = country, 
    age.limits = age_limits, 
    symmetric = symmetric,
    filter = filter_text,
    estimated.contact.age = "sample",
    n = boots
  )
  if(matrix_output){
    if(boots == 1){
      return(x$matrix)
    } else {
      return(x$matrices)
    }  
  } else {
    
    return(x)
  }  
}
```

## Code for matrix by location 
Should be able to pass the same arguments as those in contact_matrix for age bands, sampling, bootstrapping etc. 
```{r}
cm_filter(df_u, boots=1)
cm_filter(df_u, boots=1,symmetric = T, filter=T,work=1)
cm_filter(df_u, boots=1,symmetric=T, filter=T, school=1)
cm_filter(df_u, boots=1,symmetric=T, filter=T, home=1)
cm_filter(df_u, boots=1, symmetric=T, filter=T, other=1)


```

##Matrix sanity checks


```{r}
##Raw counts of average number of contacts per person in each age group made with other age groups
contact%>%filter(study_site=="Urban")%>%
  mutate(part_age_cat = case_when(
          is.na(part_age)~NA_character_,
          part_age<=17 ~ "0-17",
          part_age <=60~"18-59",
          TRUE ~ "60+"
  ),
        cont_age_cat = case_when(
          is.na(contact_age)~NA_character_,
          contact_age=="20-29y"|contact_age=="30-39y"|contact_age=="40-59y" ~ "18-59",
          contact_age== "60+y" ~ "60+y",
          TRUE~ "0-17"
        ))%>%
  group_by(part_id,part_age_cat,cont_age_cat)%>%summarise(n=n())%>%
  group_by(part_age_cat,cont_age_cat)%>%
  summarise(mean = mean(n))%>%
  filter(!is.na(cont_age_cat))%>%
  pivot_wider(names_from = cont_age_cat, values_from = mean)
```

```{r}
#Remove those missing contact, no weighting, no symmetry, sample contact age
m_u1 <- contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=F,  ##symmetric matrix
                      missing.contact.age="remove", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = F,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u1 <- Reduce("+", lapply(m_u1$matrices, function(x) {x$matrix})) / length(m_u1$matrices)

mat_u1 <- reshape2::melt(mr_u1, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c("[0,18)","[18,50)","50+"),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")
```

```{r}
#Remove those missing contact, no weighting, no symmetry, take mid point of contact age
m_u2 <- contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=F,  ##symmetric matrix
                      missing.contact.age="remove", estimated.contact.age = "mean",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = F,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u2 <- Reduce("+", lapply(m_u2$matrices, function(x) {x$matrix})) / length(m_u2$matrices)
mat_u2 <- reshape2::melt(mr_u2, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c("[0,18)","[18,50)","50+"),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")

```


```{r}
#Sample those missing contact, no weighting, no symmetry, sample contact age
m_u3 <- contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=F,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = F,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u3 <- Reduce("+", lapply(m_u3$matrices, function(x) {x$matrix})) / length(m_u3$matrices)
mat_u3 <- reshape2::melt(mr_u3, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c("[0,18)","[18,50)","50+"),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")
t(mr_u3)
mr_u3

#Sample those missing contact, no weighting, no symmetry, sample contact age
m_r3 <- contact_matrix(df_r, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=F,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = F,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_r3 <- Reduce("+", lapply(m_r3$matrices, function(x) {x$matrix})) / length(m_r3$matrices)
mat_r3 <- reshape2::melt(mr_r3, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c("[0,18)","[18,50)","50+"),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")

mr_r3
t(mr_r3)
```



```{r}
#Sample those missing contact, age weighting, no symmetry, sample contact age
m_u4 <- contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=F,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = T,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u4 <- Reduce("+", lapply(m_u4$matrices, function(x) {x$matrix})) / length(m_u4$matrices)
mat_u4 <- reshape2::melt(mr_u4, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c("[0,18)","[18,50)","50+"),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")
```

```{r}
#Sample those missing contact, no age weighting, symmetry, sample contact age
m_u5 <- contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=T,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = F,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u5<- Reduce("+", lapply(m_u5$matrices, function(x) {x$matrix})) / length(m_u5$matrices)
mat_u5 <- reshape2::melt(mr_u5, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c(1,2,3),
                            age_part = c("[0,18)","[18,50)","50+")),
                            by="age1")

```



```{r}
#Sample those missing contact, age weighting, symmetry, sample contact age
m_u6 <- contact_matrix(df_u, 
                      age.limits = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,99), ##Specify age bands for the matrix
                      symmetric=T,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = T,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u6 <- Reduce("+", lapply(m_u6$matrices, function(x) {x$matrix})) / length(m_u6$matrices)
mat_u6 <- reshape2::melt(mr_u6, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       left_join(data.frame(age1 = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15),
                            age_part = c("[0,5)","[5,10)]","[10,15)","[15,20)","[20,25)","[25,30)","[30,35)",
                                         "[35,40)","[40,45)","[45,50)","[50,55)","[55,60)","[60,65)","[65,70)","70+")),
                            by="age1")%>%
       mutate(age_part = factor(age_part, levels =  c("[0,5)","[5,10)]","[10,15)","[15,20)","[20,25)","[25,30)","[30,35)",
                                         "[35,40)","[40,45)","[45,50)","[50,55)","[55,60)","[60,65)","[65,70)","70+")))

#Sample those missing contact, age weighting, symmetry, sample contact age
m_u7 <- contact_matrix(df_u, 
                      age.limits = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,99), ##Specify age bands for the matrix
                      symmetric=F,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = F,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

#Code to take the mean of matrices
mr_u7 <- Reduce("+", lapply(m_u7$matrices, function(x) {x$matrix})) / length(m_u7$matrices)
mat_u7 <- reshape2::melt(mr_u7, varnames = c("age1", "age_cont"), value.name = "contacts") %>%
       mutate(age_part = factor(age1, levels =  c("[0,5)","[5,10)]","[10,15)","[15,20)","[20,25)","[25,30)","[30,35)",
                                         "[35,40)","[40,45)","[45,50)","[50,55)","[55,60)","[60,65)","[65,70)","70+")))

```

```{r}
p1 <- ggplot(mat_u, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
    theme(legend.position = "none")+ggtitle("symmetric, age weighed, sample missing age, sample contact age estimate")

p2 <- ggplot(mat_u1, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
     theme(legend.position = "none")+ggtitle("no symmetric,no age weighed, remove missing age, sample contact age estimate")

p3 <- ggplot(mat_u2, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
     theme(legend.position = "none")+ggtitle("no symmetric,no age weighed, remove missing age, midpoint contact age estimate")

p4 <- ggplot(mat_u3, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
     theme(legend.position = "none")+ggtitle("no symmetric,no age weighed, sample missing age, sample contact age estimate")

p5<- ggplot(mat_u4, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
     theme(legend.position = "none")+ggtitle("no symmetric,age weighed, sample missing age, sample contact age estimate")

p6 <- ggplot(mat_u5, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 3.4, limit = c(0,7))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
    theme(legend.position = "none")+ggtitle("symmetric,no age weighed, sample missing age, sample contact age estimate")

p7 <- ggplot(mat_u6, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 2.25, limit = c(0,4.5))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
    theme()+ggtitle("symmetric, age weighed, sample missing age, sample contact age estimate")

p8 <- ggplot(mat_u7, aes(x = age_part, y = age_cont, fill = contacts)) + theme(legend.position = "bottom") + 
    scale_fill_gradient2(low = "white", high = "#273871", mid = "#7FABD3", midpoint = 2.25, limit = c(0,4.5))+
    xlab("Age of participant")+ylab("Age of contact")+
    geom_tile()+
    geom_text(aes(label=round(contacts, digits=2)), colour = "black", check_overlap = TRUE)+
    theme()+ggtitle("symmetric, age weighed, sample missing age, sample contact age estimate")

png("matrix_prep_compare.png", width = 12,height = 12,units="in",res=400)
ggarrange(p1,p4,p5,p6,ncol=2,nrow=2, align="v",widths=c(1, 1))
dev.off()

```

```{r}
contact_matrix(df_u, 
                      age.limits = c(0,18,50,99), ##Specify age bands for the matrix
                      symmetric=T,  ##symmetric matrix
                      missing.contact.age="sample", estimated.contact.age = "sample",  ##what to do if missing contact age group, use sample with bootstraping
                      weigh.age = T,
                      return.part.weights=T, 
                      n=1000)     ##Number of bootstraps

```





